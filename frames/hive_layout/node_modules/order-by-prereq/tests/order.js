var tap = require('tap');
var util = require('util');
var order = require('./../lib/order').OrderByPrereq;

tap.test('order using defaults', function (test) {

    var bar = {
        id: 'bar'
    };
    var a = {
        id: 'a',
        requires: ['foo']
    };

    var b = {
        id: 'b',
        requires: ['a']
    };

    var foo = {
        id: 'foo',
        requires: ['bar']
    };

    var list = _.shuffle([
        a,
        b,
        foo,
        bar
    ]);

    var ordered_list = order(list);
    // console.log('list: %s', util.inspect(list));
    // console.log('ordered: %s', util.inspect(ordered_list));
    test.deepEqual(ordered_list, [ bar,
        foo,
        a,
        b ], 'simple reorder');

    test.end();
});

tap.test('order using custom keys', function (test) {

    test.test('order by string keys', function (tk) {
        var bar = {
            name: 'bar'
        };
        var a = {
            name: 'a',
            requires: ['foo']
        };

        var b = {
            name: 'b',
            requires: ['a']
        };

        var foo = {
            name: 'foo',
            requires: ['bar']
        };

        var list = _.shuffle([
            a,
            b,
            foo,
            bar
        ]);

        var ordered_list = order(list, 'name');
        tk.deepEqual(ordered_list, [ bar,
            foo,
            a,
            b ], 'simple reorder with id key');

        tk.end();

    });

    test.test('order by function key', function(fk){
        var bar = {
            name: 'bar'
        };
        var a = {
            name: 'a',
            requires: ['FOO']
        };

        var b = {
            name: 'b',
            requires: ['A']
        };

        var foo = {
            name: 'foo',
            requires: ['BAR']
        };

        var list = _.shuffle([
            a,
            b,
            foo,
            bar
        ]);

        var ordered_list = order(list, function(item){
            return item.name.toUpperCase();
        });
        fk.deepEqual(ordered_list, [ bar,
            foo,
            a,
            b ], 'simple reorder with functional key');

        fk.end();
    });

    test.end();
});

tap.test('order using abstract map', function (test){

    var a = {id: 'a'},
        b = {id: 'b'},
        c = {id: 'c'},
        d = {id: 'd'};

    var map = {
        a: ['b', 'c'],
        b: ['d'],
        c: ['b']
    };

    var items = _.shuffle([
    a, b, c, d
    ]);

    var dep_map = function(item){
        return map[item.id] || [];
    }

    var ordered_list = order(items, 'id', dep_map);
 //   console.log('ordered by depmap: %s', util.inspect(ordered_list));
    test.deepEqual(ordered_list, [d, b, c, a], 'ordered by dep map');
    test.end();

});

tap.test('bad reqs', function(test){

    test.test('circular references', function (circ) {

        var bar = {
            id: 'bar'
        };
        var a = {
            id: 'a',
            requires: ['b']
        };

        var b = {
            id: 'b',
            requires: ['a']
        };

        var list = _.shuffle([
            a,
            b
        ]);

        try {
            order(list);
            throw new Error('processed circular list')
        } catch (err) {
            circ.ok(/cannot reduce/.test(err.toString()), 'circular process throws error');
            circ.end();
        }


    });

    test.test('unmet requirements', function (unmet) {

        var bar = {
            id: 'bar'
        };
        var a = {
            id: 'a',
            requires: ['b']
        };

        var b = {
            id: 'b',
            requires: ['c']
        };

        var list = _.shuffle([
            a,
            b
        ]);

        try {
            var ordered = order(list);
            throw new Error('processed circular list')
        } catch (err) {
            unmet.ok(/missing requirements/.test(err.toString()), 'unmet requirements throws error');
            unmet.end();
        }

    })
    test.end();
});

